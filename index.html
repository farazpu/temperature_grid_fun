<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Heat Diffusion Grid</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #1a1a1a;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        font-family: sans-serif;
        color: #eee;
      }
      h1 {
        margin-bottom: 12px;
      }
      #controls {
        margin-bottom: 12px;
      }
      #controls button {
        padding: 10px 24px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        border-radius: 6px;
        background: #e06030;
        color: #fff;
        transition: background 0.2s;
      }
      #controls button:hover {
        background: #c04820;
      }
      canvas {
        border: 4px solid #ccc;
        image-rendering: pixelated;
        display: block;
        touch-action: none;
      }
      #canvasWrap {
        position: relative;
      }
      #numbersCanvas {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <h1>Temperature Grid</h1>
    <div id="controls">
      <label for="gridW">W:</label>
      <input id="gridW" type="number" min="10" max="1000" value="200" style="width: 60px; padding: 6px; font-size: 14px; border-radius: 6px; border: none" />
      <label for="gridH">H:</label>
      <input id="gridH" type="number" min="10" max="1000" value="200" style="width: 60px; padding: 6px; font-size: 14px; border-radius: 6px; border: none; margin-right: 12px" />
      <button id="btnResize">Resize</button>
      <label for="tempSelect" style="margin-left: 12px; margin-right: 8px">Temperature:</label>
      <select id="tempSelect" style="padding: 8px; font-size: 16px; border-radius: 6px; border: none"></select>
      <button id="btnRandom">Randomly Fill Grid</button>
      <label for="brushSize" style="margin-left: 12px; margin-right: 8px">Brush:</label>
      <input id="brushSize" type="number" min="1" max="100" value="5" style="width: 55px; padding: 6px; font-size: 14px; border-radius: 6px; border: none" />
      <label style="margin-left: 12px; cursor: pointer"><input id="chkNumbers" type="checkbox" style="margin-right: 4px" />Show Numbers</label>
    </div>
    <div id="canvasWrap">
      <canvas id="gridCanvas"></canvas>
      <canvas id="numbersCanvas"></canvas>
    </div>

    <script>
      // --- Configuration ---
      let GRID_W = 200; // grid width  (columns)
      let GRID_H = 200; // grid height (rows)
      const CANVAS_MAX = 800; // longest CSS display edge

      // --- Canvas setup ---
      const canvas = document.getElementById("gridCanvas");
      const ctx = canvas.getContext("2d");
      const numbersCanvas = document.getElementById("numbersCanvas");
      const nctx = numbersCanvas.getContext("2d");

      // --- Mutable state that is rebuilt on resize ---
      let temp = new Uint8Array(GRID_W * GRID_H);
      let imgData = ctx.createImageData(GRID_W, GRID_H);
      let pixels = imgData.data;

      function applyCanvasSize() {
        canvas.width = GRID_W;
        canvas.height = GRID_H;
        // Scale so the larger axis = CANVAS_MAX, preserving aspect ratio
        const scale = CANVAS_MAX / Math.max(GRID_W, GRID_H);
        const cssW = Math.round(GRID_W * scale);
        const cssH = Math.round(GRID_H * scale);
        canvas.style.width = cssW + "px";
        canvas.style.height = cssH + "px";

        numbersCanvas.width = cssW;
        numbersCanvas.height = cssH;
        numbersCanvas.style.width = cssW + "px";
        numbersCanvas.style.height = cssH + "px";
      }
      applyCanvasSize();

      /** Resize the grid, clearing all data. */
      function resizeGrid(w, h) {
        GRID_W = Math.max(10, Math.min(1000, w | 0));
        GRID_H = Math.max(10, Math.min(1000, h | 0));
        temp = new Uint8Array(GRID_W * GRID_H);
        imgData = ctx.createImageData(GRID_W, GRID_H);
        pixels = imgData.data;
        applyCanvasSize();
      }

      document.getElementById("btnResize").addEventListener("click", () => {
        const w = parseInt(document.getElementById("gridW").value, 10);
        const h = parseInt(document.getElementById("gridH").value, 10);
        resizeGrid(w, h);
      });

      // --- Weather-overlay colour map (index 1..100) ---
      // Stops: 1 white → 20 blue → 40 cyan → 55 green → 70 yellow → 85 orange → 100 red
      function buildColourLUT() {
        const stops = [
          { t: 1, r: 255, g: 255, b: 255 },
          { t: 20, r: 60, g: 80, b: 255 },
          { t: 40, r: 0, g: 200, b: 255 },
          { t: 55, r: 0, g: 220, b: 0 },
          { t: 70, r: 255, g: 255, b: 0 },
          { t: 85, r: 255, g: 140, b: 0 },
          { t: 100, r: 220, g: 0, b: 0 },
        ];
        const lut = new Uint8Array(101 * 3); // indices 0..100, each 3 bytes (r,g,b)
        // index 0 → white (unused cell)
        lut[0] = 255;
        lut[1] = 255;
        lut[2] = 255;
        let si = 0;
        for (let t = 1; t <= 100; t++) {
          while (si < stops.length - 2 && t > stops[si + 1].t) si++;
          const a = stops[si],
            b = stops[si + 1];
          const f = (t - a.t) / (b.t - a.t);
          const idx = t * 3;
          lut[idx] = Math.round(a.r + (b.r - a.r) * f);
          lut[idx + 1] = Math.round(a.g + (b.g - a.g) * f);
          lut[idx + 2] = Math.round(a.b + (b.b - a.b) * f);
        }
        return lut;
      }
      const colourLUT = buildColourLUT();

      // --- Drawing helpers ---
      let showNumbers = false;
      document.getElementById("chkNumbers").addEventListener("change", (e) => {
        showNumbers = e.target.checked;
      });

      function drawCells() {
        for (let i = 0, len = GRID_W * GRID_H; i < len; i++) {
          const v = showNumbers ? 0 : temp[i];
          const ci = v * 3;
          const pi = i * 4;
          pixels[pi] = colourLUT[ci];
          pixels[pi + 1] = colourLUT[ci + 1];
          pixels[pi + 2] = colourLUT[ci + 2];
          pixels[pi + 3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
      }

      function drawGrid() {
        ctx.save();

        // Minor grid lines (every 10 cells)
        ctx.strokeStyle = "rgba(0,0,0,0.12)";
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        for (let i = 10; i < Math.max(GRID_W, GRID_H); i += 10) {
          if (i % 100 === 0) continue;
          if (i < GRID_W) {
            ctx.moveTo(i, 0);
            ctx.lineTo(i, GRID_H);
          }
          if (i < GRID_H) {
            ctx.moveTo(0, i);
            ctx.lineTo(GRID_W, i);
          }
        }
        ctx.stroke();

        // Major grid lines (every 100 cells)
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 100; i < Math.max(GRID_W, GRID_H); i += 100) {
          if (i < GRID_W) {
            ctx.moveTo(i, 0);
            ctx.lineTo(i, GRID_H);
          }
          if (i < GRID_H) {
            ctx.moveTo(0, i);
            ctx.lineTo(GRID_W, i);
          }
        }
        ctx.stroke();

        // Border
        ctx.strokeStyle = "rgba(0,0,0,0.7)";
        ctx.lineWidth = 3;
        ctx.strokeRect(1, 1, GRID_W - 2, GRID_H - 2);

        ctx.restore();
      }

      function drawNumbers() {
        nctx.clearRect(0, 0, numbersCanvas.width, numbersCanvas.height);
        if (!showNumbers) return;

        const cellW = numbersCanvas.width / GRID_W;
        const cellH = numbersCanvas.height / GRID_H;
        if (cellW < 8 || cellH < 8) return;

        const fontSize = Math.max(8, Math.floor(Math.min(cellW, cellH) * 0.45));
        nctx.save();
        nctx.textAlign = "center";
        nctx.textBaseline = "middle";
        nctx.font = "bold " + fontSize + "px monospace";

        for (let y = 0; y < GRID_H; y++) {
          for (let x = 0; x < GRID_W; x++) {
            const v = temp[y * GRID_W + x];
            const ci = v * 3;
            const lum = colourLUT[ci] * 0.299 + colourLUT[ci + 1] * 0.587 + colourLUT[ci + 2] * 0.114;
            nctx.fillStyle = lum > 140 ? "#000" : "#fff";
            nctx.fillText(String(v), (x + 0.5) * cellW, (y + 0.5) * cellH);
          }
        }
        nctx.restore();
      }

      // --- Public API: set a cell temperature ---
      function setTemp(x, y, value) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
        temp[y * GRID_W + x] = Math.max(0, Math.min(100, value | 0));
      }

      function getTemp(x, y) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return 0;
        return temp[y * GRID_W + x];
      }

      // --- Random fill ---
      function randomFill() {
        for (let i = 0, len = GRID_W * GRID_H; i < len; i++) {
          temp[i] = 1 + Math.floor(Math.random() * 100); // 1..100
        }
      }
      document.getElementById("btnRandom").addEventListener("click", randomFill);

      // --- Mouse painting ---
      let painting = false;
      let paintValue = 100;
      let activePointerId = null;

      function paintAt(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = GRID_W / rect.width;
        const scaleY = GRID_H / rect.height;
        const cx = Math.floor((e.clientX - rect.left) * scaleX);
        const cy = Math.floor((e.clientY - rect.top) * scaleY);
        const R = parseInt(document.getElementById("brushSize").value, 10) || 1;
        for (let dy = -R; dy <= R; dy++) {
          for (let dx = -R; dx <= R; dx++) {
            if (dx * dx + dy * dy <= R * R) {
              setTemp(cx + dx, cy + dy, paintValue);
            }
          }
        }
      }

      // --- Populate temperature dropdown ---
      const tempSelect = document.getElementById("tempSelect");
      for (let v = 1; v <= 100; v++) {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        if (v === 100) opt.selected = true;
        tempSelect.appendChild(opt);
      }

      canvas.addEventListener("pointerdown", (e) => {
        if (e.pointerType === "mouse" && e.button !== 0) return;
        painting = true;
        activePointerId = e.pointerId;
        canvas.setPointerCapture(e.pointerId);
        if (e.shiftKey) paintValue = 0;
        else if (e.ctrlKey) paintValue = 50;
        else paintValue = parseInt(tempSelect.value, 10);
        paintAt(e);
      });

      canvas.addEventListener("pointermove", (e) => {
        if (!painting || e.pointerId !== activePointerId) return;
        paintAt(e);
      });

      function stopPainting(e) {
        if (e.pointerId !== activePointerId) return;
        if (canvas.hasPointerCapture(e.pointerId)) {
          canvas.releasePointerCapture(e.pointerId);
        }
        painting = false;
        activePointerId = null;
      }

      canvas.addEventListener("pointerup", stopPainting);
      canvas.addEventListener("pointercancel", stopPainting);
      canvas.addEventListener("pointerleave", stopPainting);

      // Prevent context menu on canvas so ctrl-click works
      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      // --- Per-frame update (calls simulation module) ---
      function update() {
        updateGrid();
      }
    </script>
    <script src="simulation2.js"></script>
    <script>
      // --- Game loop ---
      function gameLoop() {
        update();
        drawCells();
        drawGrid();
        drawNumbers();
        requestAnimationFrame(gameLoop);
      }
      gameLoop();
    </script>
  </body>
</html>
